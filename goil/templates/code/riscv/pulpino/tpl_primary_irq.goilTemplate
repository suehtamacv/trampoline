.global tpl_interruption_handler

%#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
let objForIRQ := @[ ]

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let isr::KIND := "ISR"
  let objForIRQ[key] += isr
end foreach

# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := @( )
  end if
  let cnt::KIND := "COUNTER"
  let objForIRQ[key] += cnt
end foreach

#------------------------------------------------------------------------------*
# ISR1 cannot use the same IRQ as ISR2 or COUNTER.
#
foreach irq in objForIRQ do
  let objISR1 := @()
  let objOther := @()
  # look if the list contains an ISR1
  foreach obj in irq do
    if exists obj::CATEGORY then
      if obj::CATEGORY == 1 then
        let objISR1 += obj
      else
        let objOther += obj
      end if
    end if
  end foreach
  if [objISR1 length] > 0 & [objOther length] > 0 then
    foreach isr1 in objISR1 do
      error isr1::SOURCE : "Cannot use same IRQ for an ISR1 and an ISR2 or COUNTER"
      foreach obj in objOther do
        error obj::SOURCE : "Was used here"
      end foreach
    end foreach
  end if
end foreach

let INTERRUPTMAP := mapof INTERRUPT by NAME

# Build the list of IRQ handlers to call
let irqStageList := @( )

# Build a list of virtual objects (sources of interrupts) each of them holding values :
# handlerSource, handlerName, handlerAck, generatePrimaryIrq
foreach objList in objForIRQ do
  let anIrq::handlerSource := KEY
  let anIrq::handlerName := objList[0]::NAME
  let anIrq::handlerAck := false
  let anIrq::generatePrimaryIrq := false
  foreach obj in objList do
    let anIrq::handlerAck := INTERRUPTMAP[anIrq::handlerSource]::ACK
    if obj::KIND == "ISR" then
      if obj::CATEGORY == 1 then
        let generatePrimaryIrq := true
      end if
    end if
  end foreach
  let irqStageList += anIrq 
end foreach

#------------------------------------------------------------------------------*
%/**
 * @file tpl_primary_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * Generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

#include <pulpino.h>
#include <tpl_asm_definitions.h>

#define NO_NEED_SWITCH_NOR_SCHEDULE 0
#define NO_NEED_SWITCH 0
#define NEED_SWITCH 1
#define NEED_SAVE 2
#define EXCEPTION_STACK_SIZE 144

.extern tpl_kern
.extern tpl_it_vectors

tpl_interruption_handler:
  addi sp, sp, -EXCEPTION_STACK_SIZE
  sw x1, 0x8C(x2)
  jal x1, store_regs
  la x1, end_except

  /* Creates stack */
  addi sp, sp, -16
  sw a5, 0(sp)
  sw a6, 4(sp)
  sw a7, 8(sp)

  /* Retrieves pointer to handler */
  la a5, tpl_it_vectors
  csrr a6, mcause
  slli a6, a6, 2
  add a5, a5, a6
  lw a5, -4(a5)
  jr a5

tpl_no_context_switch:
  /* Checks whether to reenable interruptions in next eret */
  la a5, tpl_reentrancy_counter
  lw a5, 0(a5)
  bnez a5, 1f
  csrsi 0x7c0, 1 //mestatus
1:
  /* Reloads working registers */
  la ra, end_except
  lw a7, 8(sp)
  lw a6, 4(sp)
  lw a5, 0(sp)
  addi sp, sp, 16
        
  /* Returns */
  ret

tpl_save_context_it:
  sw sp, 0(a0)
  csrr a6, mepc
  sw a6, 4(a0)
  la a6, tpl_reentrancy_counter
  lw a6, 0(a6)
  sw a6, 20(a0)
  ret

tpl_load_context_it:
  lw sp, 0(a0)
  lw a6, 4(a0)
  csrw mepc, a6
  la a5, tpl_reentrancy_counter
  lw a6, 20(a0)
  sw a6, 0(a5)
  ret

%

foreach irq in irqStageList
  before
%

%
  do
    let handlerSource := irq::handlerSource
    let handlerName := irq::handlerName
    let handlerIRQ := handlerSource."_Handler"
    if not irq::generatePrimaryIrq then
%
/*=============================================================================
 * IRQ Handler for IRQ % !handlerName % with source vector % !handlerSource %
 ******************************************************************************/
%
      template if exists handler_body
    end if
  after
%
%
end foreach

%

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */

